\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{listings}

\setbeamercovered{invisible}
\usetheme{Frankfurt}
\usefonttheme{serif}

% Configurar los listings (Códigos)
\renewcommand{\lstlistingname}{Código}
\lstset{
	language=C++,               % Lenguaje
	basicstyle=\ttfamily\footnotesize,  % Tipo de fuente
	keywordstyle=\color{blue},  % Color de palabras clave
	stringstyle=\color{red},    % Color de strings
	commentstyle=\color{gray},  % Color de comentarios
	showstringspaces=false,     % No muestrar el _ cuando el string tiene espacios
	breaklines = true,          % Partir las líneas largas
	breakatwhitespace=true,	    % Partir las líneas en un espacio
	numbers=left,				% Numerar las líneas a la izq
	numberstyle=\tiny,			% Poner los números de las líneas pequeños
	numberblanklines=true,      % Numerar las líneas en blanco
	columns=fullflexible,       % No perder el formato al dejar los espacios
	keepspaces=true,   			% Dejar los espacios insertados
	frame=tb,					% Poner el recuadro
}


\title{Semillero de Programación}
\subtitle{Ordenamiento Topológico, Componentes Fuertemente Conexas y Estructuras de Datos}
\author{Ana Echavarría \and Juan Francisco Cardona}

\institute{Universidad EAFIT}
\date{8 de marzo de 2013}

\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\frametitle{Contenido}
	\tableofcontents
\end{frame}

\section{Ordenamiento Topológico}
	\begin{frame}
		\frametitle{DAG}
		\begin{block}{DAG}
			Un DAG (Directed Acyclic Graph) es un grafo dirigido que no tiene ciclos.
		\end{block}
		\begin{center} \includegraphics[height = 0.4\textheight]{DAG.png} \end{center}
	\end{frame}
	
	\begin{frame}
		\frametitle{Ordenamiento Topológico}
		\begin{block}{Ordenamiento Topológico}
			Un ordenamiento topológico o topological sort de un DAG $G = (V, E)$ es un ordenamiento lineal de sus nodos $V$ de tal forma que si $(u, v) \in E$ entonces $u$ aparece antes que $v$ en el ordenamiento.\\
			Este ordenamiento se puede ver como una forma de poner todos los nodos en una línea recta y que las aristas vayan todas de izquierda a derecha.
		\end{block}
	\end{frame}
	
	\begin{frame}
		\frametitle{Ejemplo}
		\includegraphics[width = 0.95\textwidth]{toposort.png}
	\end{frame}
	
	\begin{frame}
		\frametitle{Algoritmo}
		\begin{enumerate}
			\item Hacer un DFS con el grafo
			\item Cuando marco un nodo como negro, lo inserto a un vector
			\item Reversar el orden de los elementos del vector
			\item El vector contiene un ordenamiento topológico del grafo
		\end{enumerate}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Algoritmo}
		\begin{lstlisting}
			vector <int> g[MAXN];
			bool seen[MAXN];
			vector <int> topo_sort;

			void dfs(int u){
			   seen[u] = true;
			   for (int i = 0; i < g[u].size(); ++i){
			      int v = g[u][i];
			      if (!seen[v]) dfs(v);
			   }
			   topo_sort.push_back(u); // Agregar el nodo al vector
			}
			int main(){
			   // Build graph: n = verices 
			   topo_sort.clear();
			   for (int i = 0; i < n; ++i) seen[i] = false;   
			   for (int i = 0; i < n; ++i) if (!seen[i]) dfs(i);  
			   reverse(topo_sort.begin(), topo_sort.end());
			   return 0;
			}
		\end{lstlisting}
	\end{frame}
	
	\begin{frame}
		\frametitle{Ejemplo}
		\begin{center} \includegraphics[height = 0.7\textheight]{DAG.png} \end{center}
	\end{frame}
	
	\begin{frame}
		\frametitle{¿Por qué funciona?}
		\begin{itemize}
			\item Cuando meto un nodo a la lista, es porque ya procesé todos sus vecinos.
			\item Si ya procesé todos sus vecinos, ellos ya están en la lista.
			\item Cuando meto un nodo a la lista, todos sus vecinos ya están antes que él en la lista, entonces en el ordenamiento van a quedar después de él.
			\item En conclusión, en el ordenamiento que generamos, los vecinos de cada nodo van a estar después de él por lo que es un ordenamiento topológico.
		\end{itemize}
	\end{frame}
	
	\begin{frame}
		\frametitle{Complejidad}
		\begin{block}{Complejidad}
			Hacer el ordenamiento topológico toma $O(V+E)$ para el dfs y $O(V)$ para reversar la lista. En total la complejidad es $O(V+E)$.
		\end{block}
	\end{frame}


\section{Componentes Fuertemente Conexas}
	\begin{frame}
		\frametitle{Componentes Fuertemente Conexas}
		\begin{block}{SCC}
			Dado un grafo dirigido $G = (V, E)$, un componente fuertemente conexa o strongly connected component (SCC) de $G$ es un subconjunto $C$ de nodos que cumple que para cada pareja $u, v \in C$ existe un camino de $u$ a $v$ y de $v$ a $u$ y que $C$ es lo más grande posible. 
		\end{block}
		\begin{center} \includegraphics[height = 0.3\textheight]{scc.png} \end{center}
	\end{frame}
	
	\begin{frame}
		\frametitle{Algoritmo}
		\begin{enumerate}
			\item Crear el grafo $G$ y el grafo $G_{rev}$ que es el mismo que $G$ pero con las aristas invertidas.
			\item Hacer DFS en el grafo G y generar su ``ordenamiento topológico'' (incluir un nodo a la lista solo cuando haya visto todos los nodos alcanzables desde él.)
			\item Hacer un DFS en el grafo reversado $G_{rev}$ pero hacer las llamadas en el orden del ``ordenamiento topológico''.
			\item Cada llamado a este último DFS halla una componente fuertemente conexa.
		\end{enumerate}
	\end{frame}
	
	\begin{frame}
		\frametitle{Ejemplo}
		\begin{center} \includegraphics[height = 0.5\textheight]{scc.png} \end{center}
	\end{frame}
	
	\begin{frame}[allowframebreaks]
		\frametitle{¿Por qué funciona?}
		\begin{enumerate}
			\item Las componentes fuertemente conexas de $G$ son las mismas que las de $G_{rev}$.
			\item Si comprimo los nodos de una misma componente en un solo nodo, quedo con un DAG.
			\item Si tengo dos componentes distintas $C_1$ y $C_2$ de manera que haya una arista de un nodo de $C_1$ a un nodo de $C_2$, entonces todos los nodos de $C_1$ van a quedar después que los nodos de $C_2$ en el ``ordenamiento topológico'' que se hace con el primer DFS.
			\framebreak
			\item Los nodos que quedan de primeros en el ``ordenamiento topológico'' son los nodos de una componente $C$ a la cual no llega ninguna arista.
			\item En el grafo $G_{rev}$, de la componente $C$ no sale ninguna arista.
			\item Cuando llamo el segundo DFS lo hago desde $C$ y sólo descubro los elementos de $C$.
			\item Cuando llamo el segundo DFS desde otro nodo este puede no tener aristas salientes o tener aristas salientes a $C$ pero como ya descubrí todo en $C$ sólo voy a descubrir lo que hay en la componente de ese nodo
		\end{enumerate}
	\end{frame}

\section{Dominos}
	\begin{frame}
		\frametitle{Problema 11504 - Dominos}
		\begin{block}{Problema}
			Hallar el mínimo número de dominós que hay que derribar a mano para que todos los dominós se derriben.
		\end{block}
	\end{frame}
	
	\begin{frame}
		\frametitle{Ideas}
		\begin{alertblock}{Ideas}
			\begin{itemize}
				\item ¿Qué pasa con las cadenas de dominós que forman un ciclo? ¿Cuántos necesito máximo para derribarlas? \pause
				\item ¿Puedo entonces considerar los ciclos como un sólo dominó? ¿Qué algoritmo estoy utilizando? \pause
				\item ¿En el grafo que se forma cuando uno los elementos de una misma componentes cuántos dominós tengo que derribar?
			\end{itemize}
		\end{alertblock}
	\end{frame}
	
	\begin{frame}
		\frametitle{Solución}
		\begin{enumerate}
			\item Crear el grafo dirigido y su grafo invertido
			\item Hallar la componente fuertemente conexa de cada nodo
			\item Hallar cuantas aristas llegan a cada componente conexa
			\item Contar cuantas componentes hay a las cuales no lleguen aristas
		\end{enumerate}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Variables globales}
		\begin{lstlisting}
			// El maximo numero de dominos
			const int MAXN = 100005; 
			// El grafo
			vector <int> g[MAXN];
			// El grafo reversado    
			vector <int> grev[MAXN];
			// El "ordenamiento topologico" del grafo G 
			vector <int> topo_sort;  
			// La componente fuertemente conexa a la que pertenece cada nodo
			int scc[MAXN];  
			// El arreglo de visitado para el primer DFS         
			bool seen[MAXN];
			 // El numero de aristas entrantes a cada componente         
			int in[MAXN];           
		\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{DFS}
		\begin{lstlisting}
			// DFS donde se halla el ordenamiento topologico
			void dfs1(int u){ 
			   seen[u] = true;
			   for (int i = 0; i < g[u].size(); ++i){
			      int v = g[u][i];
			      if (!seen[v]) dfs1(v);
			   }
			   topo_sort.push_back(u);
			}
			// DFS donde se hallan las componentes
			void dfs2(int u, int comp){ 
			   scc[u] = comp;
			   for (int i = 0; i < grev[u].size(); ++i){
			      int v = grev[u][i];
			      if (scc[v] == -1) dfs2(v, comp);
			   }
			}
		\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile, allowframebreaks]
		\frametitle{Main}
		\begin{lstlisting}
			int main(){
			   int cases; cin >> cases;
			   while (cases--){
			      int n, m;
			      cin >> n >> m;
			
			      // Limpiar las variables entre caso y caso
			      for (int i = 0; i <= n; ++i){
			         g[i].clear();
			         grev[i].clear();
			         topo_sort.clear();
			         scc[i] = -1;
			         seen[i] = false;
			         in[i] = 0;
			      }
			
			
			
			      // Crear el grafo y el grafo reversado
			      for (int i = 0; i < m; ++i){
			         int u, v; cin >> u >> v;
			         u--; v--;
			         g[u].push_back(v);
			         grev[v].push_back(u);
			      }
			
			      // Llamar el primer dfs
			      for (int i = 0; i < n; ++i){
			         if (!seen[i]) dfs1(i);
			      }
			      reverse(topo_sort.begin(), topo_sort.end()); 
			      // Llamar el segundo dfs
			      int comp = 0;
			      for (int i = 0; i < n; ++i){
			         int u = topo_sort[i];
			         if (scc[u] == -1) dfs2(u, comp++);
			      }
			
			      // Ver cuantas aristas entrantes tiene cada componente
			      for (int u = 0; u < n; ++u){
			         for (int i = 0; i < g[u].size(); ++i){
			            int v = g[u][i];
			            if (scc[u] != scc[v]) in[scc[v]]++;
			         }
			      }
			
			      // Sumar las componentes que tienen 0 aristas entrantes
			      int count = 0;
			      for (int u = 0; u < comp; ++u){
			         if (in[u] == 0) count++;
			      }
			      cout << count << endl;
			   }
			    return 0;
			}
		\end{lstlisting}
	\end{frame}
\end{document}