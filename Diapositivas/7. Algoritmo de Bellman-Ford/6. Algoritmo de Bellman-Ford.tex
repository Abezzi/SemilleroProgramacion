\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows}

\setbeamercovered{invisible}
\usetheme{Frankfurt}
\usefonttheme{serif}

% Configurar los listings (Códigos)
\renewcommand{\lstlistingname}{Código}
\lstset{
	language=C++,               % Lenguaje
	basicstyle=\ttfamily\footnotesize,  % Tipo de fuente
	keywordstyle=\color{blue},  % Color de palabras clave
	stringstyle=\color{red},    % Color de strings
	commentstyle=\color{gray},  % Color de comentarios
	showstringspaces=false,     % No muestrar el _ cuando el string tiene espacios
	breaklines = true,          % Partir las líneas largas
	breakatwhitespace=true,	    % Partir las líneas en un espacio
	numbers=left,				% Numerar las líneas a la izq
	numberstyle=\tiny,			% Poner los números de las líneas pequeños
	numberblanklines=true,      % Numerar las líneas en blanco
	columns=fullflexible,       % No perder el formato al dejar los espacios
	keepspaces=true,   			% Dejar los espacios insertados
	frame=tb,					% Poner el recuadro
}

\AtBeginSection[]{%
  \begin{frame}<beamer>
    \frametitle{Contenido}
    \tableofcontents[sectionstyle=show/hide,subsectionstyle=hide/show/hide]
  \end{frame}
  \addtocounter{framenumber}{-1}% If you don't want them to affect the slide number
}

\title{Semillero de Programación}
\subtitle{Algoritmo de Bellman-Ford}
\author{Ana Echavarría \and Juan Francisco Cardona}

\institute{Universidad EAFIT}
\date{22 de marzo de 2013}

\begin{document}

\begin{frame}
	\titlepage
\end{frame}

\begin{frame}
	\frametitle{Contenido}
	\tableofcontents
\end{frame}

\section{Problemas semana anterior}
	\subsection{Problema A - Non-Stop Travel}
	\begin{frame}
		\frametitle{Problema A - Non-Stop Travel}
		
	\end{frame}
	
	\begin{frame}[fragile, allowframebreaks]
		\frametitle{Implementación}
		\begin{lstlisting}
		
		\end{lstlisting}
	\end{frame}
	
	\subsection{Problema B - Peter's Smokes}
	\begin{frame}
		\frametitle{Problema B - Peter's Smokes}
		
	\end{frame}
	
	\begin{frame}[fragile, allowframebreaks]
		\frametitle{Implementación}
		\begin{lstlisting}
		
		\end{lstlisting}
	\end{frame}
	
	\subsection{Problema C - Fire Station}
	\begin{frame}
		\frametitle{Problema C - Fire Station}
	\end{frame}
	
	\begin{frame}[fragile, allowframebreaks]
		\frametitle{Implementación}
		\begin{lstlisting}
			
		\end{lstlisting}
	\end{frame}

\section{Grafos con peso negativo}
	\begin{frame}
		\frametitle{Motivación}
		Sea el grafo $G = (V, E)$ un grafo donde
		\begin{itemize}
			\item{$V$ es un conjunto de moléculas químicas}
			\item{$(u, v) \in E$ si existe una reacción química que convierta la molécula $u$ en la molécula $v$.}
			\item{$f(e)$ es la energía requerida para hacer la reacción $e \in E$}
			\item{Si una reacción consume energía $f(e) > 0$ y si produce energía $f(e) < 0$.}
		\end{itemize}
		¿Qué hacer si se quiere hallar la mínima energía para convertir una molécula en otra?
	\end{frame}

	\begin{frame}
		\frametitle{Grafos con pesos negativos}
		Algunas veces se necesita hallar el camino más corto desde una fuente a todos los demás nodos en un grafo que tiene pesos negativos.\\
		El algoritmo de Bellman-Ford encuentra esos caminos.
	\end{frame}
	
	\begin{frame}
		\frametitle{Ciclos con peso negativo}
		\begin{center}
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
			                    thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]

				\node[main node] (1) {1};
				\node[main node] (2) [right of=1] {2};
				\node[main node] (3) [above right of=2] {3};
				\node[main node] (4) [below right of=3] {4};
				\node[main node] (5) [right of=4] {5};

				\path[every node/.style={font=\sffamily\small}]
				(1) edge node {3} (2)
				(2) edge [bend left] node[left] {-2} (3)
				(3) edge [bend left] node[right] {-2} (4)
				(4) edge node {1} (2)
					edge node {5} (5);
			\end{tikzpicture}
		\end{center}
		\begin{alertblock}{}
			\begin{center}
				¿Cuál es la distancia más corta del nodo 1 al nodo 5?
			\end{center}
		\end{alertblock}
		\pause
		\begin{exampleblock}{}
			\begin{center}
				Se tiene el camino con peso -$\infty$ \\
				1 - (2 - 3 - 4) - (2 - 3 - 4) - $\cdots$ - (2 - 3 - 4) - 5.
			\end{center}
		\end{exampleblock}
	\end{frame}
	
	\begin{frame}
		\frametitle{Ciclos con peso negativo}
		\begin{itemize}
			\item El problema del camino más corto está bien definido siempre y cuando no se tengan ciclos de peso negativo alcanzables desde la fuente.
			\item Si el grafo contiene ciclos de peso negativo alcanzables desde s el problema no está bien definido porque no hay ningún camino más corto saliendo desde la fuente.
			\item Si se tiene un camino ``más corto'' desde s, este se puede hacer aún más corto si se hace una vuelta más al ciclo de peso negativo.
			% \item Si hay un ciclo de peso negativo en un camino de $s$ a $v$ se dice que $\delta (s, v) = -\infty$
		\end{itemize}
	\end{frame}


\section{Algoritmo de Bellman-Ford}

	\begin{frame}
		\frametitle{Single-Source Shortest-Paths con pesos negativos}
		\textcolor{blue}{\large Entrada}\\
		\begin{itemize}
			\item Un grafo $G = (V, E)$
			\item Una función de pesos $w : E \rightarrow \mathbb{R}$ (posiblemente $w < 0$)
			\item Un nodo $s \in V$
		\end{itemize}
		\quad \\
		\textcolor{blue}{\large Objetivo}\\
		\begin{itemize}
			\item Para todo $v \in V$ hallar el camino más corto de $s$ a $v$ \\ 
				\begin{center} o \end{center}
			\item Decir que $G$ tiene un ciclo de peso negativo y que el problema no está bien definido.
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{Pregunta}
		\begin{alertblock}{Pregunta}
			Sea n el número de nodos y m el número de aristas de un grafo G. Si G no contiene ciclos de peso negativo, ¿cuál es el número máximo de aristas que puede contener un camino más corto entre dos nodos $s$ y $v$?
		\end{alertblock}
		\pause
		\begin{exampleblock}{Respuesta}
			Un camino más corto en un grafo sin ciclos de peso negativo tiene máximo n-1 aristas. \\
			Si tuviera más es porque visita algún nodo dos veces lo que implica que hay un ciclo. \\
			Como el ciclo no tiene peso negativo, se puede eliminar y reducir la longitud del camino.
		\end{exampleblock}
	\end{frame}
	
	\begin{frame}
		\frametitle{Idea principal}
		Hallar el camino más corto de $s$ a $v$ que usa máximo $i$ aristas.\\
		\begin{block}{¿Cómo hacerlo?}
			Sea $L_{i,v} $ la longitud del camino más corto de $s$ a $v$ con máximo $i$ aristas (se permiten ciclos).\\
			\[
				L_{0,v} =
				\begin{cases}
					0        &\text{si } v = s\\
					+\infty  &\text{si } v \neq s
				\end{cases}
			\]\\
			Ahora $\forall v \in V$\\
			\[ 
				L_{i,v} = \text{min } 
				\left\{
					\begin{aligned}
						& \quad L_{i-1,v}\\
						& \operatorname*{min}_{(u, v) \in E}  \left\{L_{i-1, u} + w_{u,v} \right\}\\
					\end{aligned}
				\right\}
			\]
			\quad \\
		\end{block}
	\end{frame}
	
	\begin{frame}
		\frametitle{Algoritmo cuando no hay ciclos de peso negativo}
		\begin{itemize}
			\item Asumamos que no hay ciclos de peso negativo.\\
			\item Ya vimos que el camino más corto tiene máximo $n-1$ aristas\\
			\item Para hallar la solución al problema hay que computar $L_{i, v}$ para $i = 0, 1, \ldots n-1$ y todo $v \in V$
		\end{itemize}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Algoritmo cuando no hay ciclos de peso negativo}
		\begin{lstlisting}
			Crear matriz L[MAXN][MAXN]  // L[i][u]
			Hacer L[0][s] = 0 y L[0][u] = INF para u != s
			Para i = 1 hasta n-1
			   // El camino más corto con i-1 arstas
			   Para u = 0 hasta n-1
			      L[i][u] = L[i-1][u]
			
			   // Mirar todas las aristas
			   Para u = 0 hasta n-1
			      Para k = 0 hasta g[u].size() - 1
			         v = g[u][k].first  // El nodo
			         w = g[u][k].second // El peso
			         // Mirando la arista (u, v) de peso w
			         L[i][v] = min(L[i][v], L[i-1][u] + w)
		\end{lstlisting}
	\end{frame}
	
	\begin{frame}
		\frametitle{Ejemplo}
		\begin{center}
			\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.5cm,
			                    thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]

				\node[main node] (1) {1};
				\node[main node] (2) [above right of=1] {2};
				\node[main node] (3) [below right of=1] {3};
				\node[main node] (4) [right of=2] {4};
				\node[main node] (5) [right of=3] {5};

				\path[every node/.style={font=\sffamily\small}]
				(1) edge node {2} (2)
				    edge node {4} (3)
				(2) edge node {-1} (3)
				    edge node {2} (4)
					edge node {1} (5)
				(3) edge node {-2} (5)
				(4) edge node {5} (5);
			\end{tikzpicture}
		\end{center}
	\end{frame}
	
	\begin{frame}
		\frametitle{Complejidad}
		\begin{alertblock}{Complejidad}
			¿Cuál de las siguientes es la mejor aproximación a la complejidad del algoritmo cuando no hay ciclos de peso negativo?
			\setbeamercovered{transparent}
			\begin{itemize}
				\item<1> [a] $O(n^2)$ 
				\item<1,2> [b] $O(n \cdot m)$
				\item<1> [c] $O(n ^ 3)$
				\item<1> [d] $O(m ^ 2)$
			\end{itemize}
			\setbeamercovered{invisible}
		\end{alertblock}
	\end{frame}
	
	\begin{frame}
	\end{frame}
	

\section{Tarea}
	\begin{frame}[fragile]
		\frametitle{Tarea}
		\begin{alertblock}{Tarea}
			Resolver los problemas de \url{}
		\end{alertblock}
	\end{frame}
\end{document}